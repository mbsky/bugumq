#summary 使用示例

= BuguMQ的使用示例 =

==建立连接==
{{{
Connection conn = Connection.getInstance();
conn.setHost("192.168.0.200");
conn.setPassword("foobared");
conn.connect();
}}}

一个应用中，应该只有一个Connection，在应用开始的时候连接一次。在应用退出的时候，记得断开该连接：

{{{
conn.disconnect();
}}}

Connection内部使用了连接池，默认最多是8个连接，你可以自己定义这个数值，如下：
{{{
JedisPoolConfig config = new JedisPoolConfig();
config.setMaxActive(10);  //最多10个连接
conn.setPoolConfig(config);
        
conn.connect();
}}}
关于JedisPoolConfig的更多参数设置，请[https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/jedis/JedisPoolConfig.java 查看其源代码]。

==获取Client==
{{{
Client client = conn.getClient();
}}}

==产生Queue消息==
{{{
client.produce("q1", "hello");
client.produce("q2", "world");

//产生紧急消息
client.produceUrgency("q1", "hurry up!");

//产生有效期为1分钟的消息
client.produce("q1", 60, "my message");

//产生2020年6月26日到期的消息
Date expireAt = parseDate("2020-06-26");
client.produce("q1", expireAt, "my message");
}}}

==获取队列中消息数量==
{{{
long size = client.getQueueSize("q1");
}}}

==删除队列中的消息==
{{{
//清除队列中的消息，只保留最新的5条。
client.retainQueue("q1", 5);

//清除队列中的全部消息
//client.clearQueue("q1");
}}}

==消费Queue消息==
{{{
QueueListener listener = new QueueListener(){
    @Override
    public void onQueueMessage(String queue, String message) {
        System.out.println("queue: " + queue);
        System.out.println("message: " + message);
    }
};
client.consume(listener, "q1", "q2");
}}}

一个client，可以有多个QueueListener。一个QueueListener，可以监听一个或多个Queue的消息。

==停止消费==
{{{
client.stopConsume("q1");

//停止所有的消费
//client.stopAllConsume();
}}}

==发布Topic消息==
{{{
client.publish("topic/1", "hello");
client.publish("topic/2", "world");

//发布保留消息
client.publishRetain("topic/2", "welcome!");
}}}

==清除Topic上的保留消息==
{{{
client.clearRetainMessage("topic/2");
}}}

==订阅Topic消息==
{{{
TopicListener listener = new TopicListener(){
    @Override
    public void onTopicMessage(String topic, String message) {
        System.out.println("topic: " + topic);
        System.out.println("message: " + message);
    }
            
    @Override
    public void onPatternMessage(String pattern, String topic, String message) {
        System.out.println("pattern: " + pattern);
        System.out.println("topic: " + topic);
        System.out.println("message: " + message);
    }
};
        
client.setTopicListener(listener);
        
client.subscribe("topic/1", "topic/2");

//按模式订阅
//client.subscribePattern("topic/*");
}}}

*注意：*

（1）一个Client，只有一个TopicListener，用来监听所有的Topic消息。这一点与Queue消息不同。

（2）请尽量一次订阅多个Topic，而不要逐个订阅。因为在BuguMQ内部，每次订阅，都需要产生一个新的线程。

（3）按模式订阅时，无法获接收到Topic上的保留消息。

==退订==
{{{
client.unsubscribe("topic/1", "topic/2");

//按模式退订
//client.unsubscribePattern("topic/*");
}}}

==获取订阅者数量==
{{{
long count = client.getSubsribersCount("topic/1");
}}}

==清空MQ服务器中的所有消息==
{{{
client.flushDB();
}}}

==文件传输==
Client类提供了以下方法，用于文件传输：
{{{
//设置文件传输监听器
public void listenFile(FileListener fileListener, String myClientId)

//请求传输文件
public void requestSendFile(String filePath, String toClientId)

//同意接收文件
public void agreeReceiveFile(String toClientId, long fileId, String filePath, long fileLength)

//拒绝接收文件
public void rejectReceiveFile(String toClientId, long fileId, String filePath, long fileLength)

//发送文件数据
public void sendFileData(long fileId, byte[] data)

//发送文件结束标识符
public void sendEndOfFile(long fileId)
}}}
其中，FileListener是一个监听器类，它是一个抽象类，包含5个抽象方法：
{{{
//对方请求传输文件
public abstract void onRequest(String fromClientId, long fileId, String filePath, long fileLength);

//对方同意接收文件    
public abstract void onAgree(String fromClientId, long fileId, String filePath, long fileLength);

//对方拒绝接收文件    
public abstract void onReject(String fromClientId, long fileId, String filePath, long fileLength);

//接收到文件数据    
public abstract void onFileData(long fileId, byte[] data);

//接收到文件传输结束的消息    
public abstract void onFileEnd(long fileId);
}}}

示例代码：

发送方：
{{{
    public void send() throws Exception {
        String myClientId = "sender_id";
        //监听文件传输
        client.listenFile(new SendFileListener(), myClientId);
        
        String filePath = "/Users/frankwen/send/redis.pdf";
        String toClientId = "receiver_id";
        //请求传输文件给对方
        client.requestSendFile(filePath, toClientId);
    }
    
    class SendFileListener extends FileListener{
        @Override
        public void onRequest(String fromClientId, long fileId, String filePath, long fileLength){
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void onAgree(String fromClientId, long fileId, String filePath, long fileLength) {
            System.out.println(fromClientId + " 同意接收文件：" + filePath);
            //开始分块发送文件
            try{
                Client client = Connection.getInstance().getClient();
                FileInputStream fis = new FileInputStream(filePath);
                int chunkSize = 8 * 1024;
                byte[] chunkData = new byte[chunkSize];
                int bytesRead = fis.read(chunkData, 0, chunkSize);
                while(bytesRead > 0){
                    if(bytesRead == chunkSize){
                        client.sendFileData(fileId, chunkData);
                    }else{
                        client.sendFileData(fileId, Arrays.copyOfRange(chunkData, 0, bytesRead));
                    }
                    bytesRead = fis.read(chunkData, 0, chunkSize);
                }
                //发送文件结束标识符
                client.sendEndOfFile(fileId);
            }catch(Exception ex){
                
            }
        }

        @Override
        public void onReject(String fromClientId, long fileId, String filePath, long fileLength) {
            System.out.println(fromClientId + " 拒绝接收文件：" + filePath);
        }

        @Override
        public void onFileData(long fileId, byte[] data) {
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void onFileEnd(long fileId) {
            throw new UnsupportedOperationException("Not supported yet.");
        }
        
    }
}}}

接收方：
{{{
    public void receive() throws Exception {
        String myClientId = "receiver_id";
        //监听文件传输
        client.listenFile(new ReceiveFileListener(), myClientId);
    }
    
    class ReceiveFileListener extends FileListener{
        
        private FileOutputStream fos;
        
        @Override
        public void onRequest(String fromClientId, long fileId, String filePath, long fileLength){
            System.out.println(fromClientId + " 请求向您发送文件：" + filePath);
            //发送消息，同意接收文件
            Client client = Connection.getInstance().getClient();
            try{
                client.agreeReceiveFile(fromClientId, fileId, filePath, fileLength);
            }catch(Exception ex){
                
            }
            //新建文件，并打开文件输出流
            try{
                File file = new File("/Users/frankwen/receive/new_file.pdf");
                file.createNewFile();
                fos = new FileOutputStream(file);
            }catch(Exception ex){
                
            }
        }

        @Override
        public void onAgree(String fromClientId, long fileId, String filePath, long fileLength) {
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void onReject(String fromClientId, long fileId, String filePath, long fileLength) {
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void onFileData(long fileId, byte[] data) {
            try{
                fos.write(data);
            }catch(Exception ex){
                
            }
            
        }

        @Override
        public void onFileEnd(long fileId) {
            try{
                fos.flush();
                fos.close();
            }catch(Exception ex){
                
            }
        }
        
    }
}}}

*注意：*

（1）clientId是能够唯一标识该客户端的字符串。

（2）filePath是文件的绝对路径。

（3）当有多个文件同时在传输的时候，需要用fileId进行区分。fileId是由BuguMQ自动产生的、能唯一区分不同文件的long型数值。